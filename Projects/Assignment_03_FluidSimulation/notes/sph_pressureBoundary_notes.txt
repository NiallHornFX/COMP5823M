particles sat atop each other from projection, nans and incorrect density, pressure. Actually dont think this is issue at it happens even with spiky and postions themselves of r are nan.

Ok so yeah it is coming from pressure grad / force calc...

When pt.j dens = 0, resulting pressure grad is 0, then we get -0 = nan ? 

Particles with zero density due to them been outside the Kernel radius, probs should set them to some eps and not 0. Shouldn't be using particles outside kernel radius as neighbours, this is the issue
with not using a grid or using particles in cells outside of kernel radius. So we could just skip any particles whom density is zero. Ok that fixes it. But this shouldnt be an issue when we are only searching
close particles via hash grid or uniform grid (i disable spatial accel for debugging which seems to create another nan bug in this case). We could also just enforce a small eps of density for all particles to stop
this occuring, ie no particle is ever 0 density.  

Other source of nans when particles are atop each other kernel yields nan, this could just be poly6 grad issue ie if (pt_i - pt_j == 0) result of kernel is nan ? I think this is the main issue. 
Spiky is better but still get cases where r = 0 returns nan from spiky gradient. 

So nans were caused by divide by zero for both cases A) Dividng by zero density on Pt_j, B) Divding by length of zero vector when (pt_i - pt_j == 0).

Ah its to do with the normalization of the r vector, if r is 0, which direction do we project ..? 

For dens calcluatlion, dont skip self (i==j) will ensure density is never 0. 

Pressure not been computed correctly post collision so restoriatve pressure force never works correctly. 

Basically seems to be pressure solve failing at boundary, when fluid is falling pressure correctly breaks it up/apart from been too close, but when collided, even with no fric etc, it just fails. 

test if 1.0 kernel rad is too large or small by checking if particles r < h and storing n count. 

Is it to do with collision after integration ? So pressure force int to pos, is overriden each timestep for these particles ... ? No bc in C++ the collision is before integrate... 

Still think its kernel radius been too big, because larger radius weights down closer particles, which may be why when particles come too close their pressure is not enough to resolve. 

Getting simmilar results with Houdini's SPH Solver when kernel radius is too large... Also if pressure str is too low

Think I will just go with ghost particle layer idea and still do projection on active pts, then wont have to worry about boundary layer forming. 


Resovled Issues
Smoothing Kernel can be below 1 and get best results with it been around 0.35-0.5. Otherwise if its larger the pressure force of closer particles is reduced as the radius is too large. 
This made more sense than scaling the scene/units up in the end.

Nans were from gradient calc vector been 0 vector and thus divide by zero. 

The volume loss is to do with the collisions/boundary layer still not entirely sure the issue (possibly ordofoperations), one hack is to impose pressure on particles at the boundary.
I recreated the issue in houdini with a strippe down SPH solver, and it seems when I use regular collison projection we get the stuck particle without pressure, but using their collisions
the particles flow correctly and maintain volume, not sure entirely what they are doing for this to work so well. 

Viscosity genreally helps the particle distribtuon to be more even, I impose some fake viscosity on velocity as damping directly like 0.999 each tick, this is a bit of a hack. 

Pressure is clamped to be positive only, surf tension needs to be controlled by to be implemented surf tension force. 

Ok yeah so it was purely a kernel radius issue. Dont even need to enforce fake pressure at boundaries now. However this fix doesn't work for my Houdini Debug version, the Houdini version seems to be purely
a collision issue, where when using projection the volume presevation fails, this is so simmilar to what was happening in C++ it makes me think the issue is still related, but apart from implementations using
ghost particles at boundaries everyone else seems to use position projection fine. However the Houdini version was producing the exact same beahviour when projection collisions were used vs whatever
approach Houdini uses via DOPs (I think they use projection but are doing something addiotnal on the vel, I tried all sorts to replicate this like removing normal vel but keeping tang etc, still couldnt replactate it). 

Houdinis delta might be due to projection been done as a post solve step, where as in C++ its done before integration so the pressure force is applied within the same timestep post projection. Yeah so if I apply it within
the Particle Fluid Solver, before the pressure force I get better results (still doesnt match Houdnis native collisions but their probs doing something different with their post collision velocity). 

Anyhow reducing the Kernel Radius < 1 seems to fix my issues in the C++ solver, my bad for thinking there Kernel Radius could not be below 1.0 